/* BOLT Programming Language Grammar
   This is a simplified version that excludes:
   - Function calls
   - Complex types (vector, matrix, tensor)
   - The defer statement
*/
    import AbstractSyntax.Statements.*;
    import AbstractSyntax.Expressions.*;
    import AbstractSyntax.Types.*;
    import java.util.ArrayList;

COMPILER BOLT

/* Code to be injected at the start of the parser class */

    public Stmt mainNode = null; // This contains the AST generated by calling parser.Parse()

    public boolean hasErrors() {
        return errors.count > 0;
    }

    private Stmt toComp(ArrayList<Stmt> stmtsReversed) {
        if (stmtsReversed.isEmpty())
            return null;

        Stmt result = stmtsReversed.get(0);
        for (int i = 1; i < stmtsReversed.size(); i++) {
            result = new Comp(result, stmtsReversed.get(i));
        }
        return result;
    }

/*------------------------------------------------------------------------*/
/* Token specification */
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  lf  = '\n'.
  cr = '\r'.
  tab = '\t'.
  any = ANY - "'" - '\\' - cr - lf.
  anyChar = ANY.

TOKENS
  IDENT  = letter {letter | digit | '_'}.
  INTNUM = digit {digit}.
  DOUBLENUM = digit {digit} '.' digit {digit}.
  CHARLIT = "'" (any | "\\" anyChar) "'".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab + ' '

/*------------------------------------------------------------------------*/
/* Grammar productions */
PRODUCTIONS

BOLT<out Stmt result> =
  Program<out result>
  (. mainNode = result; .)
.

Program<out Stmt result> =      (. ArrayList<Stmt> statements = new ArrayList<>(); .)
  Statement<out Stmt stmt>      (. if (stmt != null) statements.add(stmt); .)
  {
    Statement<out stmt>         (. if (stmt != null) statements.add(stmt); .)
  }
  (.
    // Create compound statements from the list
    if (statements.isEmpty()) {
        result = null;
    } else if (statements.size() == 1) {
        result = statements.get(0);
    } else {
        result = statements.get(0);
        for (int i = 1; i < statements.size(); i++) {
            result = new Comp(result, statements.get(i));
        }
    }
  .)
.

Statement<out Stmt result> =     (. result = null; .)
  (
    SimpleStatement<out result>
  | WhileStatement<out result>
  | IfStatement<out result>
  )
.

SimpleStatement<out Stmt result> = (. result = null; .)
  (
    Declaration<out result> ";"
  | Assignment<out result> ";"
  )
.

Declaration<out Stmt result> =   (. Type type = null; Expr initialValue = null; int lineNumber = t.line; .)
  Type<out type>
  IDENT                          (. String id = t.val; lineNumber = t.line; .)
  [
    ":="
    Expression<out initialValue>
  ]                              (. result = new Declaration(type, id, initialValue, null); .)
.

Assignment<out Stmt result> =    (. Expr expr = null; int lineNumber = t.line; .)
  IDENT                          (. String id = t.val; lineNumber = t.line; .)
  ":="
  Expression<out expr>           (. result = new Assign(id, expr); .)
.

Type<out Type result> =          (. result = null; .)
  (
    "double"                     (. result = new SimpleType(SimpleTypesEnum.DOUBLE); .)
  | "int"                        (. result = new SimpleType(SimpleTypesEnum.INT); .)
  | "char"                       (. result = new SimpleType(SimpleTypesEnum.CHAR); .)
  | "bool"                       (. result = new SimpleType(SimpleTypesEnum.BOOL); .)
  )
.

WhileStatement<out Stmt result> = (. Expr condition = null; Stmt body = null; int lineNumber = t.line; .)
  "while"                        (. lineNumber = t.line; .)
  "("
  Expression<out condition>
  ")"
  "do"
  "{"
  Statement<out body>
  "}"                            (. result = new While(body, condition); .)
.

IfStatement<out Stmt result> =   (. Expr condition = null; Stmt thenBranch = null; Stmt elseBranch = null; int lineNumber = t.line; .)
  "if"                           (. lineNumber = t.line; .)
  "("
  Expression<out condition>
  ")"
  "then"
  "{"
  Statement<out thenBranch>
  "}"
  [
    "else"
    "{"
    Statement<out elseBranch>
    "}"
  ]                              (. result = new If(thenBranch, elseBranch, condition); .)
.

Expression<out Expr result> =
  OrExpression<out result>
.

OrExpression<out Expr result> =   (. result = null; int lineNumber; .)
  AndExpression<out result>
  {
    "||"                         (. lineNumber = t.line; .)
    AndExpression<out Expr right> (. result = new BinExpr(result, right, Binoperator.OR); .)
  }
.

AndExpression<out Expr result> =  (. result = null; int lineNumber; .)
  EqualityExpression<out result>
  {
    "&&"                         (. lineNumber = t.line; .)
    EqualityExpression<out Expr right> (. result = new BinExpr(result, right, Binoperator.AND); .)
  }
.

EqualityExpression<out Expr result> = (. result = null; Binoperator opType; int lineNumber; .)
  RelationalExpression<out result>
  {
    (
      "=="                       (. opType = Binoperator.EQUAL; lineNumber = t.line; .)
    | "!="                       (. opType = Binoperator.NEQUAL; lineNumber = t.line; .)
    )
    RelationalExpression<out Expr right> (. result = new BinExpr(result, right, opType); .)
  }
.

RelationalExpression<out Expr result> = (. result = null; Binoperator opType; int lineNumber; .)
  AdditiveExpression<out result>
  {
    (
      "<"                        (. opType = Binoperator.LT; lineNumber = t.line; .)
    | "<="                       (. opType = Binoperator.LEQ; lineNumber = t.line; .)
    | ">"                        (. opType = Binoperator.GT; lineNumber = t.line; .)
    | ">="                       (. opType = Binoperator.GEQ; lineNumber = t.line; .)
    )
    AdditiveExpression<out Expr right> (. result = new BinExpr(result, right, opType); .)
  }
.

AdditiveExpression<out Expr result> = (. result = null; Binoperator opType; int lineNumber; .)
  MultiplicativeExpression<out result>
  {
    (
      "+"                        (. opType = Binoperator.ADD; lineNumber = t.line; .)
    | "-"                        (. opType = Binoperator.MINUS; lineNumber = t.line; .)
    )
    MultiplicativeExpression<out Expr right> (. result = new BinExpr(result, right, opType); .)
  }
.

MultiplicativeExpression<out Expr result> = (. result = null; Binoperator opType; int lineNumber; .)
  UnaryExpression<out result>
  {
    (
      "*"                        (. opType = Binoperator.TIMES; lineNumber = t.line; .)
    | "/"                        (. opType = Binoperator.DIV; lineNumber = t.line; .)
    | "%"                        (. opType = Binoperator.MODULO; lineNumber = t.line; .)
    )
    UnaryExpression<out Expr right> (. result = new BinExpr(result, right, opType); .)
  }
.

UnaryExpression<out Expr result> = (. result = null; Expr operand = null; int lineNumber; .)
  (
    "!"                          (. lineNumber = t.line; .)
    UnaryExpression<out operand> (. result = new UnExpr(operand, Unaryoperator.NOT); .)
  |
    "-"                          (. lineNumber = t.line; .)
    UnaryExpression<out operand> (. result = new UnExpr(operand, Unaryoperator.NEG); .)
  |
    Primary<out result>
  )
.

Primary<out Expr result> = (. result = null; int lineNumber; .)
  (
    IDENT                        (. result = new Ident(t.val); lineNumber = t.line; .)
  | INTNUM                       (. result = new IntVal(Integer.parseInt(t.val)); lineNumber = t.line; .)
  | DOUBLENUM                    (. result = new DoubleVal(Double.parseDouble(t.val)); lineNumber = t.line; .)
  | CHARLIT                      (.
                                    // Simple character literal parsing
                                    String s = t.val;
                                    char charValue;
                                    if (s.length() == 3) {
                                        // Normal character like 'a'
                                        charValue = s.charAt(1);
                                    } else {
                                        // Escaped character like '\n'
                                        switch (s.charAt(2)) {
                                            case 'n': charValue = '\n'; break;
                                            case 't': charValue = '\t'; break;
                                            case 'r': charValue = '\r'; break;
                                            case '\\': charValue = '\\'; break;
                                            case '\'': charValue = '\''; break;
                                            default: charValue = s.charAt(2);
                                        }
                                    }
                                    result = new CharVal(charValue);
                                    lineNumber = t.line;
                                 .)
  | "true"                       (. result = new BoolVal(true); lineNumber = t.line; .)
  | "false"                      (. result = new BoolVal(false); lineNumber = t.line; .)
  | "("
    Expression<out Expr tempExpr>
    ")"                          (. result = new ParenExpr(tempExpr); .)
  )
.

END BOLT.