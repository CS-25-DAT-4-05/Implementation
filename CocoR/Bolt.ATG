/* BOLT Programming Language Grammar with complex types */
import AbstractSyntax.Statements.*;
import AbstractSyntax.Expressions.*;
import AbstractSyntax.Types.*;
import AbstractSyntax.SizeParams.*;
import AbstractSyntax.Definitions.*;
import AbstractSyntax.Program.*;
import java.util.ArrayList;
import Lib.Pair;

COMPILER BOLT

/* Code to be injected at the start of the parser class */

public Prog mainNode = null; // contains the AST generated by calling parser.Parse()
public boolean debugMode = true; // Debug mode - set to true for detailed tracing

public boolean hasErrors() {
    return errors.count > 0;
}

// debug tracing method
private void trace(String message) {
    if (debugMode) {
        System.out.println("[TRACE] " + message + " at line " + la.line + ", col " + la.col);
    }
}

// rule tracing method
private void traceRule(String ruleName) {
    if (debugMode) {
        System.out.println("[RULE] " + ruleName + " at line " + la.line);
    }
}

// Error reporting
private void ReportDetailedError(String message, int line, int col) {
    errors.Warning(line, col, message);
    // Log the current parser state
    System.err.println("Current token: " + la.val + " (kind=" + la.kind + ")");
    System.err.println("Previous token: " + t.val + " (kind=" + t.kind + ")");
}

// helper method to chain function definitions
private FuncDef chainFunctions(ArrayList<FuncDef> functions) {
    if (functions == null || functions.isEmpty())
        return null;

    if (functions.size() == 1)
        return functions.get(0);

    // chain functions from left to right
    FuncDef result = functions.get(0);
    FuncDef current = result;
    for (int i = 1; i < functions.size(); i++) {
        current.nextFunc = functions.get(i);
        current = functions.get(i);
    }
    return result;
}

private Stmt toComp(ArrayList<Stmt> statements) {
    if (statements == null || statements.isEmpty())
        return null;

    if (statements.size() == 1)
        return statements.get(0);

    // Bygger compound statements tree, left to right
    Stmt result = statements.get(0);
    for (int i = 1; i < statements.size(); i++) {
        if (statements.get(i) != null) {
            result = new Comp(result, statements.get(i));
        }
    }
    return result;
}

/*------------------------------------------------------------------------*/
/* Token specification */
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  lf  = '\n'.
  cr = '\r'.
  tab = '\t'.
  any = ANY - "'" - '\\' - cr - lf.
  anyChar = ANY.

TOKENS
  IDENT  = letter {letter | digit | '_'}.
  INTNUM = digit {digit}.
  DOUBLENUM = digit {digit} '.' digit {digit}.
  CHARLIT = "'" (any | "\\" anyChar) "'".

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab + ' '

/*------------------------------------------------------------------------*/
/* Grammar productions */
PRODUCTIONS

BOLT<out Prog result> = (. traceRule("BOLT"); .)
  Program<out result>
  (. mainNode = result; .)
.

Program<out Prog result> = (. traceRule("Program"); .)
  (.
    trace("Starting Program parsing");
    ArrayList<FuncDef> functions = new ArrayList<>();
    FuncDef func = null;
  .)
  {
    SYNC                           (. // sync point before each function
                                      trace("Synchronizing before function");
                                   .)
    FunctionDefinition<out func>   (.
                                      if (func != null) {
                                        trace("Adding function to program: " + func.procname);
                                        functions.add(func);
                                      } else {
                                        trace("Null function encountered");
                                      }
                                   .)
  }
  (.
    trace("Finished collecting functions, count: " + functions.size());
    // chainer function definitions
    FuncDef chainedFunctions = chainFunctions(functions);
    result = new Prog(chainedFunctions);
    if (result == null || result.func == null) {
      trace("Program produced null result or no functions");
    }
  .)
.

FunctionDefinition<out FuncDef result> = (.
  traceRule("FunctionDefinition");
  Type returnType = null;
  String funcName = "";
  ArrayList<Pair<Type, String>> params = new ArrayList<>();
  ArrayList<Stmt> bodyStmts = new ArrayList<>();
  Stmt tempStmt = null;
  Expr returnExpr = null;
  int lineNumber = t.line;
  Type paramType = null;
  String paramName = "";
  boolean isVoid = false;
  trace("Starting function definition parsing");
.)
  "func:"
  Type<out returnType>           (.
                                    // Tjekker om return type er void
                                    if (returnType instanceof SimpleType) {
                                      SimpleType simpleType = (SimpleType)returnType;
                                      if (simpleType.type == SimpleTypesEnum.BOOL && t.val.equals("void")) {
                                        isVoid = true;
                                        trace("Function has void return type");
                                      }
                                    }
                                 .)
  IDENT                          (. funcName = t.val; trace("Function name: " + funcName); .)
  "("
  [
    FormalParameter<out paramType>  (.
      paramName = t.val;
      params.add(new Pair<>(paramType, paramName));
      trace("Parameter added: " + paramName);
    .)
    {
      ","
      FormalParameter<out paramType>  (.
        paramName = t.val;
        params.add(new Pair<>(paramType, paramName));
        trace("Parameter added: " + paramName);
      .)
    }
  ]
  ")"
  "{"                            (. trace("Starting function body"); .)
  FunctionBody<out bodyStmts>    (. trace("Function body parsed with " + bodyStmts.size() + " statements"); .)
  "return"                       (. trace("Processing function return"); lineNumber = t.line; .)
  [                              // Option for void funktion
    Expression<out returnExpr>   (.
                                    if (isVoid && returnExpr != null) {
                                      // Tilføjer warning hvis der returneres en værdi med en void function
                                      ReportDetailedError("Warning: Return with value in void function", lineNumber, t.col);
                                    }
                                 .)
  ]
  ";"
  "}"                            (.
                                    trace("Finished parsing function definition");
                                    Stmt body = toComp(bodyStmts);
                                    result = new FuncDef(returnType, funcName, params, body, returnExpr, null);
                                    trace("Function definition complete: " + funcName);
                                 .)
.

// Produktionsregel for funktionskrop
FunctionBody<out ArrayList<Stmt> bodyStmts> = (.
  traceRule("FunctionBody");
  bodyStmts = new ArrayList<>();
  Stmt stmt = null;
.)
  {
    (
      SimpleStatement<out stmt>
    | WhileStatement<out stmt>
    | IfStatement<out stmt>
    | DeferStatement<out stmt>
    )                            (.
                                    if (stmt != null) {
                                      trace("Adding statement to function body: " + stmt.getClass().getSimpleName());
                                      bodyStmts.add(stmt);
                                    } else {
                                      trace("Null statement in function body");
                                    }
                                 .)
  }
.

FormalParameter<out Type type> = (.
  traceRule("FormalParameter");
  type = null;
.)
  Type<out type>
  IDENT
.

SimpleStatement<out Stmt result> = (.
  traceRule("SimpleStatement");
  result = null;
.)
  (
    Declaration<out result> ";"
  | Assignment<out result> ";"
  )
.

Declaration<out Stmt result> = (.
  traceRule("Declaration");
  Type type = null; Expr initialValue = null; int lineNumber = t.line;
.)
  Type<out type>
  IDENT                          (. String id = t.val; lineNumber = t.line; .)
  [
    "="
    Expression<out initialValue>
  ]                              (. result = new Declaration(type, id, initialValue, null); .)
.

Assignment<out Stmt result> = (.
  traceRule("Assignment");
  Expr expr = null; Expr target = null; int lineNumber = t.line; result = null;
.)
  (
    IDENT                        (. String id = t.val; lineNumber = t.line; target = new Ident(id); .)
    [
      "["                        (. ArrayList<Expr> indices = new ArrayList<>(); .)
      Expression<out Expr index> (. indices.add(index); .)
      {
        ","
        Expression<out Expr nextIndex> (. indices.add(nextIndex); .)
      }
      "]"                        (. target = new TensorAccessExpr(target, indices); .)
    ]
  )
  "="
  Expression<out expr>           (.
                                   // assign handles both simple and tensor assignments
                                   result = new Assign(target, expr);
                                 .)
.

DeferStatement<out Stmt result> = (.
  traceRule("DeferStatement");
  ArrayList<Stmt> bodyStmts = new ArrayList<>();
  Stmt tempStmt = null;
  ArrayList<Pair<String,SizeParam>> dims = new ArrayList<>();
  int lineNumber = t.line;
.)
  "defer"
  "["
  "("
  IDENT                          (. String threadId = t.val; .)
  ","
  SizeExpression<out SizeParam size> (. dims.add(new Pair<>(threadId, size)); .)
  ")"
  {
    ","
    "("
    IDENT                        (. threadId = t.val; .)
    ","
    SizeExpression<out size>     (. dims.add(new Pair<>(threadId, size)); .)
    ")"
  }
  "]"
  "{"
  {
    (
      SimpleStatement<out tempStmt>
    | WhileStatement<out tempStmt>
    | IfStatement<out tempStmt>
    | DeferStatement<out tempStmt>
    )                            (. if (tempStmt != null) bodyStmts.add(tempStmt); .)
  }
  "}"                            (.
    Stmt body = toComp(bodyStmts);
    result = new Defer(dims, body);
    trace("Completed defer block with " + bodyStmts.size() + " statements and " + dims.size() + " dimensions");
  .)
.

Type<out Type result> = (.
  traceRule("Type");
  result = null; SimpleType baseType = null;
.)
  (
    SimpleType<out baseType>     (. result = baseType; .)
  |
    ComplexType<out result>
  )
.

SimpleType<out SimpleType result> = (.
  traceRule("SimpleType");
  result = null;
.)
  (
    "double"                     (. result = new SimpleType(SimpleTypesEnum.DOUBLE); .)
  | "int"                        (. result = new SimpleType(SimpleTypesEnum.INT); .)
  | "char"                       (. result = new SimpleType(SimpleTypesEnum.CHAR); .)
  | "bool"                       (. result = new SimpleType(SimpleTypesEnum.BOOL); .)
  | "void"                       (. result = new SimpleType(SimpleTypesEnum.BOOL); .) // også Void for function return types
  )
.

ComplexType<out Type result> = (.
  traceRule("ComplexType");
  result = null;
  SimpleType baseType = null;
  ArrayList<SizeParam> dimensions = new ArrayList<>();
  SizeParam size = null;
.)
  (
    "vector"
    "["
    SimpleType<out baseType>
    ","
    SizeExpression<out size>     (. dimensions.add(size); .)
    "]"                          (. result = new TensorType(baseType, dimensions); .)
  |
    "matrix"
    "["
    SimpleType<out baseType>
    ","
    SizeExpression<out size>     (. dimensions.add(size); .)
    ","
    SizeExpression<out size>     (. dimensions.add(size); .)
    "]"                          (. result = new TensorType(baseType, dimensions); .)
  |
    "tensor"
    "["
    SimpleType<out baseType>
    ","
    SizeExpression<out size>     (. dimensions.add(size); .)
    {
      ","
      SizeExpression<out size>   (. dimensions.add(size); .)
    }
    "]"                          (. result = new TensorType(baseType, dimensions); .)
  )
.

SizeExpression<out SizeParam result> = (.
  traceRule("SizeExpression");
  result = null;
.)
  (
    INTNUM                       (. result = new SPInt(Integer.parseInt(t.val)); .)
  | IDENT                        (. result = new SPIdent(t.val); .)
  )
.

WhileStatement<out Stmt result> = (.
  traceRule("WhileStatement");
  Expr condition = null;
  ArrayList<Stmt> bodyStmts = new ArrayList<>();
  Stmt tempStmt = null;
  int lineNumber = t.line;
  trace("Starting while statement parsing");
.)
  "while"                        (. lineNumber = t.line; .)
  "("
  Expression<out condition>      (. trace("While condition parsed"); .)
  ")"
  "do"
  "{"
  {
    (
      SimpleStatement<out tempStmt>
    | WhileStatement<out tempStmt>
    | IfStatement<out tempStmt>
    | DeferStatement<out tempStmt>
    )                            (.
      if (tempStmt != null) {
        bodyStmts.add(tempStmt);
        trace("Added statement to while body");
      }
    .)
  }
  "}"                            (.
    Stmt body = toComp(bodyStmts);
    result = new While(body, condition);
    trace("Completed while statement with " + bodyStmts.size() + " body statements");
  .)
.

IfStatement<out Stmt result> = (.
  traceRule("IfStatement");
  Expr condition = null;
  ArrayList<Stmt> thenStmts = new ArrayList<>();
  ArrayList<Stmt> elseStmts = new ArrayList<>();
  Stmt tempStmt = null;
  int lineNumber = t.line;
  trace("Starting if statement parsing");
.)
  "if"                           (. lineNumber = t.line; .)
  "("
  Expression<out condition>      (. trace("If condition parsed"); .)
  ")"
  "then"
  "{"
  {
    (
      SimpleStatement<out tempStmt>
    | WhileStatement<out tempStmt>
    | IfStatement<out tempStmt>
    | DeferStatement<out tempStmt>
    )                            (.
      if (tempStmt != null) {
        thenStmts.add(tempStmt);
        trace("Added statement to then branch");
      }
    .)
  }
  "}"
  [
    "else"
    "{"
    {
      (
        SimpleStatement<out tempStmt>
      | WhileStatement<out tempStmt>
      | IfStatement<out tempStmt>
      | DeferStatement<out tempStmt>
      )                          (.
        if (tempStmt != null) {
          elseStmts.add(tempStmt);
          trace("Added statement to else branch");
        }
      .)
    }
    "}"
  ]                              (.
    Stmt thenBranch = toComp(thenStmts);
    Stmt elseBranch = toComp(elseStmts);
    result = new If(thenBranch, elseBranch, condition);
    trace("Completed if statement: then=" + thenStmts.size() + " statements, else=" + elseStmts.size() + " statements");
  .)
.

Expression<out Expr result> = (. traceRule("Expression"); .)
  OrExpression<out result>
.

OrExpression<out Expr result> = (.
  traceRule("OrExpression");
  result = null; int lineNumber;
.)
  AndExpression<out result>
  {
    "||"                         (. lineNumber = t.line; .)
    AndExpression<out Expr right> (. result = new BinExpr(result, right, Binoperator.OR); .)
  }
.

AndExpression<out Expr result> = (.
  traceRule("AndExpression");
  result = null; int lineNumber;
.)
  EqualityExpression<out result>
  {
    "&&"                         (. lineNumber = t.line; .)
    EqualityExpression<out Expr right> (. result = new BinExpr(result, right, Binoperator.AND); .)
  }
.

EqualityExpression<out Expr result> = (.
  traceRule("EqualityExpression");
  result = null; Binoperator opType; int lineNumber;
.)
  RelationalExpression<out result>
  {
    (
      "=="                       (. opType = Binoperator.EQUAL; lineNumber = t.line; .)
    | "!="                       (. opType = Binoperator.NEQUAL; lineNumber = t.line; .)
    )
    RelationalExpression<out Expr right> (. result = new BinExpr(result, right, opType); .)
  }
.

RelationalExpression<out Expr result> = (.
  traceRule("RelationalExpression");
  result = null; Binoperator opType; int lineNumber;
.)
  AdditiveExpression<out result>
  {
    (
      "<"                        (. opType = Binoperator.LT; lineNumber = t.line; .)
    | "<="                       (. opType = Binoperator.LEQ; lineNumber = t.line; .)
    | ">"                        (. opType = Binoperator.GT; lineNumber = t.line; .)
    | ">="                       (. opType = Binoperator.GEQ; lineNumber = t.line; .)
    )
    AdditiveExpression<out Expr right> (. result = new BinExpr(result, right, opType); .)
  }
.

AdditiveExpression<out Expr result> = (.
  traceRule("AdditiveExpression");
  result = null; Binoperator opType; int lineNumber;
.)
  MultiplicativeExpression<out result>
  {
    (
      "+"                        (. opType = Binoperator.ADD; lineNumber = t.line; .)
    | "-"                        (. opType = Binoperator.MINUS; lineNumber = t.line; .)
    )
    MultiplicativeExpression<out Expr right> (. result = new BinExpr(result, right, opType); .)
  }
.

MultiplicativeExpression<out Expr result> = (.
  traceRule("MultiplicativeExpression");
  result = null; Binoperator opType; int lineNumber;
.)
  UnaryExpression<out result>
  {
    (
      "*"                        (. opType = Binoperator.TIMES; lineNumber = t.line; .)
    | ".*"                       (. opType = Binoperator.ELMULT; lineNumber = t.line; .)
    | "/"                        (. opType = Binoperator.DIV; lineNumber = t.line; .)
    | "%"                        (. opType = Binoperator.MODULO; lineNumber = t.line; .)
    )
    UnaryExpression<out Expr right> (. result = new BinExpr(result, right, opType); .)
  }
.

UnaryExpression<out Expr result> = (.
  traceRule("UnaryExpression");
  result = null; Expr operand = null; int lineNumber;
.)
  (
    "!"                          (. lineNumber = t.line; .)
    UnaryExpression<out operand> (. result = new UnExpr(operand, Unaryoperator.NOT); .)
  |
    "-"                          (. lineNumber = t.line; .)
    UnaryExpression<out operand> (. result = new UnExpr(operand, Unaryoperator.NEG); .)
  |
    Primary<out result>
  )
.

Primary<out Expr result> = (.
  traceRule("Primary");
  result = null; int lineNumber; Expr param = null; ArrayList elements = null;
.)
  (
    IDENT                        (. String id = t.val; lineNumber = t.line; trace("Processing identifier: " + id); .)
    (
      /* Function call */
      "("                        (. ArrayList<Expr> params = new ArrayList<>(); trace("Function call"); .)
      [
        Expression<out param>    (. params.add(param); .)
        {
          ","
          Expression<out param>  (. params.add(param); .)
        }
      ]
      ")"                        (. result = new FuncCallExpr(id, params); .)
    |
      /* Tensor access */
      "["                        (. result = new Ident(id); ArrayList<Expr> indices = new ArrayList<>(); trace("Tensor access"); .)
      Expression<out Expr index> (. indices.add(index); .)
      {
        ","
        Expression<out Expr nextIndex> (. indices.add(nextIndex); .)
      }
      "]"                        (. result = new TensorAccessExpr(result, indices); .)
    |
      /* Just an identifier */   (. result = new Ident(id); trace("Simple identifier"); .)
    )
  | INTNUM                       (. result = new IntVal(Integer.parseInt(t.val)); lineNumber = t.line; .)
  | DOUBLENUM                    (. result = new DoubleVal(Double.parseDouble(t.val)); lineNumber = t.line; .)
  | CHARLIT                      (.
                                    // Simple character literal parsing
                                    String s = t.val;
                                    char charValue;
                                    if (s.length() == 3) {
                                        // Normal character like 'a'
                                        charValue = s.charAt(1);
                                    } else {
                                        // Escaped character like '\n'
                                        switch (s.charAt(2)) {
                                            case 'n': charValue = '\n'; break;
                                            case 't': charValue = '\t'; break;
                                            case 'r': charValue = '\r'; break;
                                            case '\\': charValue = '\\'; break;
                                            case '\'': charValue = '\''; break;
                                            default: charValue = s.charAt(2);
                                        }
                                    }
                                    result = new CharVal(charValue);
                                    lineNumber = t.line;
                                 .)
  | "true"                       (. result = new BoolVal(true); lineNumber = t.line; .)
  | "false"                      (. result = new BoolVal(false); lineNumber = t.line; .)
  | "("
    Expression<out Expr tempExpr>
    ")"                          (. result = new ParenExpr(tempExpr); .)
  | "["                          (. elements = new ArrayList(); .)
    [
      TensorElements<out elements>
    ]
    "]"                          (. result = new TensorDefExpr((ArrayList<Expr>)elements); .)
  )
.

TensorElements<out ArrayList elements> = (.
  traceRule("TensorElements");
  Expr elem = null; ArrayList<Expr> temp = new ArrayList<>();
.)
  (
    "["                          (. ArrayList<Expr> subElements = new ArrayList<>(); .)
    TensorElements<out subElements>
    "]"                          (. temp.add(new TensorDefExpr(subElements)); .)
    {
      ","
      "["
      TensorElements<out subElements>
      "]"                        (. temp.add(new TensorDefExpr(subElements)); .)
    }
  |
    Expression<out elem>         (. temp.add(elem); .)
    {
      ","
      Expression<out elem>       (. temp.add(elem); .)
    }
  )                              (. elements = temp; .)
.

END BOLT.