package boltparser;

import AbstractSyntax.Statements.*;
import AbstractSyntax.Expressions.*;
import AbstractSyntax.Types.*;
import AbstractSyntax.SizeParams.*;
import AbstractSyntax.Definitions.*;
import AbstractSyntax.Program.*;
import java.util.ArrayList;
import java.util.Scanner;

//import javax.management.openmbean.SimpleType;

import Lib.Pair;



public class Parser {
	public static final int _EOF = 0;
	public static final int _IDENT = 1;
	public static final int _INTNUM = 2;
	public static final int _DOUBLENUM = 3;
	public static final int _CHARLIT = 4;
	public static final int maxT = 47;

	static final boolean _T = true;
	static final boolean _x = false;
	static final int minErrDist = 2;

	public Token t;    // last recognized token
	public Token la;   // lookahead token
	int errDist = minErrDist;
	
	public Scanner scanner;
	public Errors errors;

	public Prog mainNode = null; // contains the AST generated by calling parser.Parse()
public boolean debugMode = true; // Debug mode - set to true for detailed tracing

public boolean hasErrors() {
    return errors.count > 0;
}

// debug tracing method
private void trace(String message) {
    if (debugMode) {
        System.out.println("[TRACE] " + message + " at line " + la.line + ", col " + la.col);
    }
}

// rule tracing method
private void traceRule(String ruleName) {
    if (debugMode) {
        System.out.println("[RULE] " + ruleName + " at line " + la.line);
    }
}

// Error reporting
private void ReportDetailedError(String message, int line, int col) {
    errors.Warning(line, col, message);
    // Log the current parser state
    System.err.println("Current token: " + la.val + " (kind=" + la.kind + ")");
    System.err.println("Previous token: " + t.val + " (kind=" + t.kind + ")");
}

// helper method to chain function definitions
private FuncDef chainFunctions(ArrayList<FuncDef> functions) {
    if (functions == null || functions.isEmpty())
        return null;

    if (functions.size() == 1)
        return functions.get(0);

    // chain functions from left to right
    FuncDef result = functions.get(0);
    FuncDef current = result;
    for (int i = 1; i < functions.size(); i++) {
        current.nextFunc = functions.get(i);
        current = functions.get(i);
    }
    return result;
}

private Stmt toComp(ArrayList<Stmt> statements) {
    if (statements == null || statements.isEmpty())
        return null;

    if (statements.size() == 1)
        return statements.get(0);

    // Bygger compound statements tree, left to right
    Stmt result = statements.get(0);
    for (int i = 1; i < statements.size(); i++) {
        if (statements.get(i) != null) {
            result = new Comp(result, statements.get(i));
        }
    }
    return result;
}

/*------------------------------------------------------------------------*/
/* Token specification */


	public Parser(Scanner scanner) {
		this.scanner = scanner;
		errors = new Errors();
	}

	void SynErr (int n) {
		if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
		errDist = 0;
	}

	public void SemErr (String msg) {
		if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
		errDist = 0;
	}
	
	void Get () {
		for (;;) {
			t = la;
			la = scanner.Scan();
			if (la.kind <= maxT) {
				++errDist;
				break;
			}

			la = t;
		}
	}
	
	void Expect (int n) {
		if (la.kind==n) Get(); else { SynErr(n); }
	}
	
	boolean StartOf (int s) {
		return set[s][la.kind];
	}
	
	void ExpectWeak (int n, int follow) {
		if (la.kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}
	
	boolean WeakSeparator (int n, int syFol, int repFol) {
		int kind = la.kind;
		if (kind == n) { Get(); return true; }
		else if (StartOf(repFol)) return false;
		else {
			SynErr(n);
			while (!(set[syFol][kind] || set[repFol][kind] || set[0][kind])) {
				Get();
				kind = la.kind;
			}
			return StartOf(syFol);
		}
	}
	
	public Prog  BOLT() {
		Prog  result;
		traceRule("BOLT"); 
		result = Program();
		mainNode = result; 
		return result;
	}

	public Prog Program() {
    traceRule("Program");
    trace("Starting Program parsing");

    ArrayList<FuncDef> functions = new ArrayList<>();
    FuncDef func = null;

    while (la.kind == 5) {
        while (!(la.kind == 0 || la.kind == 5)) { SynErr(48); Get(); }
        trace("Synchronizing before function");

        func = FunctionDefinition();
        if (func != null) {
            trace("Adding function to program: " + func.procname);
            functions.add(func);
        } else {
            trace("Null function encountered");
        }
    }

    trace("Finished collecting functions, count: " + functions.size());

    FuncDef chainedFunctions = chainFunctions(functions);
    Prog result = new Prog(chainedFunctions);

    if (result == null || result.func == null) {
        trace("Program produced null result or no functions");
    }

   return new Prog(chainedFunctions);
}



	FuncDef  FunctionDefinition() {
		FuncDef  result;
		traceRule("FunctionDefinition");
		Type returnType = null;
		String funcName = "";
		ArrayList<Pair<Type, String>> params = new ArrayList<>();
		ArrayList<Stmt> bodyStmts = new ArrayList<>();
		Stmt tempStmt = null;
		Expr returnExpr = null;
		int lineNumber = t.line;
		Type paramType = null;
		String paramName = "";
		boolean isVoid = false;
		trace("Starting function definition parsing");
		
		Expect(5);
		returnType = Type();
		if (returnType instanceof SimpleType) {
		 SimpleType simpleType = (SimpleType)returnType;
		 if (simpleType.type == SimpleTypesEnum.BOOL && t.val.equals("void")) {
		   isVoid = true;
		   trace("Function has void return type");
		 }
		}
		
		Expect(1);
		funcName = t.val; trace("Function name: " + funcName); 
		Expect(6);
		if (StartOf(1)) {
			paramType = FormalParameter();
			paramName = t.val;
			params.add(new Pair<>(paramType, paramName));
			trace("Parameter added: " + paramName);
			
			while (la.kind == 7) {
				Get();
				paramType = FormalParameter();
				paramName = t.val;
				params.add(new Pair<>(paramType, paramName));
				trace("Parameter added: " + paramName);
				
			}
		}
		Expect(8);
		Expect(9);
		trace("Starting function body"); 
		bodyStmts = FunctionBody();
		trace("Function body parsed with " + bodyStmts.size() + " statements"); 
		Expect(10);
		trace("Processing function return"); lineNumber = t.line; 
		if (StartOf(2)) {
			returnExpr = Expression();
			if (isVoid && returnExpr != null) {
			 // TilfÃ¸jer warning hvis der returneres en vÃ¦rdi med en void function
			 ReportDetailedError("Warning: Return with value in void function", lineNumber, t.col);
			}
			
		}
		Expect(11);
		Expect(12);
		trace("Finished parsing function definition");
		Stmt body = toComp(bodyStmts);
		result = new FuncDef(returnType, funcName, params, body, returnExpr, null);
		trace("Function definition complete: " + funcName);
		
		return result;
	}

	Type  Type() {
		Type  result;
		traceRule("Type");
		result = null; SimpleType baseType = null;
		
		if (StartOf(3)) {
			baseType = SimpleType();
			result = baseType; 
		} else if (la.kind == 22 || la.kind == 23 || la.kind == 24) {
			result = ComplexType();
		} else SynErr(49);
		return result;
	}

	Type  FormalParameter() {
		Type  type;
		traceRule("FormalParameter");
		type = null;
		
		type = Type();
		Expect(1);
		return type;
	}

	ArrayList<Stmt>  FunctionBody() {
		ArrayList<Stmt>  bodyStmts;
		traceRule("FunctionBody");
		bodyStmts = new ArrayList<>();
		Stmt stmt = null;
		
		while (StartOf(4)) {
			if (StartOf(5)) {
				stmt = SimpleStatement();
			} else if (la.kind == 25) {
				stmt = WhileStatement();
			} else if (la.kind == 27) {
				stmt = IfStatement();
			} else {
				stmt = DeferStatement();
			}
			if (stmt != null) {
			 trace("Adding statement to function body: " + stmt.getClass().getSimpleName());
			 bodyStmts.add(stmt);
			} else {
			 trace("Null statement in function body");
			}
			
		}
		return bodyStmts;
	}

	Expr  Expression() {
		Expr  result;
		traceRule("Expression"); 
		result = OrExpression();
		return result;
	}

	Stmt  SimpleStatement() {
		Stmt  result;
		traceRule("SimpleStatement");
		result = null;
		
		if (StartOf(1)) {
			result = Declaration();
			Expect(11);
		} else if (la.kind == 1) {
			result = Assignment();
			Expect(11);
		} else SynErr(50);
		return result;
	}

	Stmt  WhileStatement() {
		Stmt  result;
		traceRule("WhileStatement");
		Expr condition = null;
		ArrayList<Stmt> bodyStmts = new ArrayList<>();
		Stmt tempStmt = null;
		int lineNumber = t.line;
		trace("Starting while statement parsing");
		
		Expect(25);
		lineNumber = t.line; 
		Expect(6);
		condition = Expression();
		trace("While condition parsed"); 
		Expect(8);
		Expect(26);
		Expect(9);
		while (StartOf(4)) {
			if (StartOf(5)) {
				tempStmt = SimpleStatement();
			} else if (la.kind == 25) {
				tempStmt = WhileStatement();
			} else if (la.kind == 27) {
				tempStmt = IfStatement();
			} else {
				tempStmt = DeferStatement();
			}
			if (tempStmt != null) {
			 bodyStmts.add(tempStmt);
			 trace("Added statement to while body");
			}
			
		}
		Expect(12);
		Stmt body = toComp(bodyStmts);
		result = new While(body, condition);
		trace("Completed while statement with " + bodyStmts.size() + " body statements");
		
		return result;
	}

	Stmt  IfStatement() {
		Stmt  result;
		traceRule("IfStatement");
		Expr condition = null;
		ArrayList<Stmt> thenStmts = new ArrayList<>();
		ArrayList<Stmt> elseStmts = new ArrayList<>();
		Stmt tempStmt = null;
		int lineNumber = t.line;
		trace("Starting if statement parsing");
		
		Expect(27);
		lineNumber = t.line; 
		Expect(6);
		condition = Expression();
		trace("If condition parsed"); 
		Expect(8);
		Expect(28);
		Expect(9);
		while (StartOf(4)) {
			if (StartOf(5)) {
				tempStmt = SimpleStatement();
			} else if (la.kind == 25) {
				tempStmt = WhileStatement();
			} else if (la.kind == 27) {
				tempStmt = IfStatement();
			} else {
				tempStmt = DeferStatement();
			}
			if (tempStmt != null) {
			 thenStmts.add(tempStmt);
			 trace("Added statement to then branch");
			}
			
		}
		Expect(12);
		if (la.kind == 29) {
			Get();
			Expect(9);
			while (StartOf(4)) {
				if (StartOf(5)) {
					tempStmt = SimpleStatement();
				} else if (la.kind == 25) {
					tempStmt = WhileStatement();
				} else if (la.kind == 27) {
					tempStmt = IfStatement();
				} else {
					tempStmt = DeferStatement();
				}
				if (tempStmt != null) {
				 elseStmts.add(tempStmt);
				 trace("Added statement to else branch");
				}
				
			}
			Expect(12);
		}
		Stmt thenBranch = toComp(thenStmts);
		Stmt elseBranch = toComp(elseStmts);
		result = new If(thenBranch, elseBranch, condition);
		trace("Completed if statement: then=" + thenStmts.size() + " statements, else=" + elseStmts.size() + " statements");
		
		return result;
	}

	Stmt  DeferStatement() {
		Stmt  result;
		traceRule("DeferStatement");
		ArrayList<Stmt> bodyStmts = new ArrayList<>();
		Stmt tempStmt = null;
		ArrayList<Pair<String,SizeParam>> dims = new ArrayList<>();
		int lineNumber = t.line;
		
		Expect(16);
		Expect(14);
		Expect(6);
		Expect(1);
		String threadId = t.val; 
		Expect(7);
		SizeParam size = SizeExpression();
		dims.add(new Pair<>(threadId, size)); 
		Expect(8);
		while (la.kind == 7) {
			Get();
			Expect(6);
			Expect(1);
			threadId = t.val; 
			Expect(7);
			size = SizeExpression();
			dims.add(new Pair<>(threadId, size)); 
			Expect(8);
		}
		Expect(15);
		Expect(9);
		while (StartOf(4)) {
			if (StartOf(5)) {
				tempStmt = SimpleStatement();
			} else if (la.kind == 25) {
				tempStmt = WhileStatement();
			} else if (la.kind == 27) {
				tempStmt = IfStatement();
			} else {
				tempStmt = DeferStatement();
			}
			if (tempStmt != null) bodyStmts.add(tempStmt); 
		}
		Expect(12);
		Stmt body = toComp(bodyStmts);
		result = new Defer(dims, body);
		trace("Completed defer block with " + bodyStmts.size() + " statements and " + dims.size() + " dimensions");
		
		return result;
	}

	Stmt  Declaration() {
		Stmt  result;
		traceRule("Declaration");
		Type type = null; Expr initialValue = null; int lineNumber = t.line;
		
		type = Type();
		Expect(1);
		String id = t.val; lineNumber = t.line; 
		if (la.kind == 13) {
			Get();
			initialValue = Expression();
		}
		result = new Declaration(type, id, initialValue, null); 
		return result;
	}

	Stmt  Assignment() {
		Stmt  result;
		traceRule("Assignment");
		Expr expr = null; Expr target = null; int lineNumber = t.line; result = null;
		
		Expect(1);
		String id = t.val; lineNumber = t.line; target = new Ident(id); 
		if (la.kind == 14) {
			Get();
			ArrayList<Expr> indices = new ArrayList<>(); 
			Expr index = Expression();
			indices.add(index); 
			while (la.kind == 7) {
				Get();
				Expr nextIndex = Expression();
				indices.add(nextIndex); 
			}
			Expect(15);
			target = new TensorAccessExpr(target, indices); 
		}
		Expect(13);
		expr = Expression();
		result = new Assign(target, expr);
		
		return result;
	}

	SizeParam  SizeExpression() {
		SizeParam  result;
		traceRule("SizeExpression");
		result = null;
		
		if (la.kind == 2) {
			Get();
			result = new SPInt(Integer.parseInt(t.val)); 
		} else if (la.kind == 1) {
			Get();
			result = new SPIdent(t.val); 
		} else SynErr(51);
		return result;
	}

	SimpleType  SimpleType() {
		SimpleType  result;
		traceRule("SimpleType");
		result = null;
		
		if (la.kind == 17) {
			Get();
			result = new SimpleType(SimpleTypesEnum.DOUBLE); 
		} else if (la.kind == 18) {
			Get();
			result = new SimpleType(SimpleTypesEnum.INT); 
		} else if (la.kind == 19) {
			Get();
			result = new SimpleType(SimpleTypesEnum.CHAR); 
		} else if (la.kind == 20) {
			Get();
			result = new SimpleType(SimpleTypesEnum.BOOL); 
		} else if (la.kind == 21) {
			Get();
			result = new SimpleType(SimpleTypesEnum.BOOL); 
		} else SynErr(52);
		return result;
	}

	Type  ComplexType() {
		Type  result;
		traceRule("ComplexType");
		result = null;
		SimpleType baseType = null;
		ArrayList<SizeParam> dimensions = new ArrayList<>();
		SizeParam size = null;
		
		if (la.kind == 22) {
			Get();
			Expect(14);
			baseType = SimpleType();
			Expect(7);
			size = SizeExpression();
			dimensions.add(size); 
			Expect(15);
			result = new TensorType(baseType, dimensions); 
		} else if (la.kind == 23) {
			Get();
			Expect(14);
			baseType = SimpleType();
			Expect(7);
			size = SizeExpression();
			dimensions.add(size); 
			Expect(7);
			size = SizeExpression();
			dimensions.add(size); 
			Expect(15);
			result = new TensorType(baseType, dimensions); 
		} else if (la.kind == 24) {
			Get();
			Expect(14);
			baseType = SimpleType();
			Expect(7);
			size = SizeExpression();
			dimensions.add(size); 
			while (la.kind == 7) {
				Get();
				size = SizeExpression();
				dimensions.add(size); 
			}
			Expect(15);
			result = new TensorType(baseType, dimensions); 
		} else SynErr(53);
		return result;
	}

	Expr  OrExpression() {
		Expr  result;
		traceRule("OrExpression");
		result = null; int lineNumber;
		
		result = AndExpression();
		while (la.kind == 30) {
			Get();
			lineNumber = t.line; 
			Expr right = AndExpression();
			result = new BinExpr(result, right, Binoperator.OR); 
		}
		return result;
	}

	Expr  AndExpression() {
		Expr  result;
		traceRule("AndExpression");
		result = null; int lineNumber;
		
		result = EqualityExpression();
		while (la.kind == 31) {
			Get();
			lineNumber = t.line; 
			Expr right = EqualityExpression();
			result = new BinExpr(result, right, Binoperator.AND); 
		}
		return result;
	}

	Expr  EqualityExpression() {
		Expr  result;
		traceRule("EqualityExpression");
		result = null; Binoperator opType; int lineNumber;
		
		result = RelationalExpression();
		while (la.kind == 32 || la.kind == 33) {
			if (la.kind == 32) {
				Get();
				opType = Binoperator.EQUAL; lineNumber = t.line; 
			} else {
				Get();
				opType = Binoperator.NEQUAL; lineNumber = t.line; 
			}
			Expr right = RelationalExpression();
			result = new BinExpr(result, right, opType); 
		}
		return result;
	}

	Expr  RelationalExpression() {
		Expr  result;
		traceRule("RelationalExpression");
		result = null; Binoperator opType; int lineNumber;
		
		result = AdditiveExpression();
		while (StartOf(6)) {
			if (la.kind == 34) {
				Get();
				opType = Binoperator.LT; lineNumber = t.line; 
			} else if (la.kind == 35) {
				Get();
				opType = Binoperator.LEQ; lineNumber = t.line; 
			} else if (la.kind == 36) {
				Get();
				opType = Binoperator.GT; lineNumber = t.line; 
			} else {
				Get();
				opType = Binoperator.GEQ; lineNumber = t.line; 
			}
			Expr right = AdditiveExpression();
			result = new BinExpr(result, right, opType); 
		}
		return result;
	}

	Expr  AdditiveExpression() {
		Expr  result;
		traceRule("AdditiveExpression");
		result = null; Binoperator opType; int lineNumber;
		
		result = MultiplicativeExpression();
		while (la.kind == 38 || la.kind == 39) {
			if (la.kind == 38) {
				Get();
				opType = Binoperator.ADD; lineNumber = t.line; 
			} else {
				Get();
				opType = Binoperator.MINUS; lineNumber = t.line; 
			}
			Expr right = MultiplicativeExpression();
			result = new BinExpr(result, right, opType); 
		}
		return result;
	}

	Expr  MultiplicativeExpression() {
		Expr  result;
		traceRule("MultiplicativeExpression");
		result = null; Binoperator opType; int lineNumber;
		
		result = UnaryExpression();
		while (StartOf(7)) {
			if (la.kind == 40) {
				Get();
				opType = Binoperator.TIMES; lineNumber = t.line; 
			} else if (la.kind == 41) {
				Get();
				opType = Binoperator.ELMULT; lineNumber = t.line; 
			} else if (la.kind == 42) {
				Get();
				opType = Binoperator.DIV; lineNumber = t.line; 
			} else {
				Get();
				opType = Binoperator.MODULO; lineNumber = t.line; 
			}
			Expr right = UnaryExpression();
			result = new BinExpr(result, right, opType); 
		}
		return result;
	}

	Expr  UnaryExpression() {
		Expr  result;
		traceRule("UnaryExpression");
		result = null; Expr operand = null; int lineNumber;
		
		if (la.kind == 44) {
			Get();
			lineNumber = t.line; 
			operand = UnaryExpression();
			result = new UnExpr(operand, Unaryoperator.NOT); 
		} else if (la.kind == 39) {
			Get();
			lineNumber = t.line; 
			operand = UnaryExpression();
			result = new UnExpr(operand, Unaryoperator.NEG); 
		} else if (StartOf(8)) {
			result = Primary();
		} else SynErr(54);
		return result;
	}

	Expr  Primary() {
		Expr  result;
		traceRule("Primary");
		result = null; int lineNumber; Expr param = null; ArrayList elements = null;
		
		switch (la.kind) {
		case 1: {
			Get();
			String id = t.val; lineNumber = t.line; trace("Processing identifier: " + id); 
			if (la.kind == 6) {
				Get();
				ArrayList<Expr> params = new ArrayList<>(); trace("Function call"); 
				if (StartOf(2)) {
					param = Expression();
					params.add(param); 
					while (la.kind == 7) {
						Get();
						param = Expression();
						params.add(param); 
					}
				}
				Expect(8);
				result = new FuncCallExpr(id, params); 
			} else if (la.kind == 14) {
				Get();
				result = new Ident(id); ArrayList<Expr> indices = new ArrayList<>(); trace("Tensor access"); 
				Expr index = Expression();
				indices.add(index); 
				while (la.kind == 7) {
					Get();
					Expr nextIndex = Expression();
					indices.add(nextIndex); 
				}
				Expect(15);
				result = new TensorAccessExpr(result, indices); 
			} else if (StartOf(9)) {
				result = new Ident(id); trace("Simple identifier"); 
			} else SynErr(55);
			break;
		}
		case 2: {
			Get();
			result = new IntVal(Integer.parseInt(t.val)); lineNumber = t.line; 
			break;
		}
		case 3: {
			Get();
			result = new DoubleVal(Double.parseDouble(t.val)); lineNumber = t.line; 
			break;
		}
		case 4: {
			Get();
			String s = t.val;
			char charValue;
			if (s.length() == 3) {
			   // Normal character like 'a'
			   charValue = s.charAt(1);
			} else {
			   // Escaped character like '\n'
			   switch (s.charAt(2)) {
			       case 'n': charValue = '\n'; break;
			       case 't': charValue = '\t'; break;
			       case 'r': charValue = '\r'; break;
			       case '\\': charValue = '\\'; break;
			       case '\'': charValue = '\''; break;
			       default: charValue = s.charAt(2);
			   }
			}
			result = new CharVal(charValue);
			lineNumber = t.line;
			
			break;
		}
		case 45: {
			Get();
			result = new BoolVal(true); lineNumber = t.line; 
			break;
		}
		case 46: {
			Get();
			result = new BoolVal(false); lineNumber = t.line; 
			break;
		}
		case 6: {
			Get();
			Expr tempExpr = Expression();
			Expect(8);
			result = new ParenExpr(tempExpr); 
			break;
		}
		case 14: {
			Get();
			elements = new ArrayList(); 
			if (StartOf(2)) {
				elements = TensorElements();
			}
			Expect(15);
			result = new TensorDefExpr((ArrayList<Expr>)elements); 
			break;
		}
		default: SynErr(56); break;
		}
		return result;
	}

	ArrayList  TensorElements() {
		ArrayList  elements;
		traceRule("TensorElements");
		Expr elem = null; ArrayList<Expr> temp = new ArrayList<>();
		
		if (la.kind == 14) {
			Get();
			ArrayList<Expr> subElements = new ArrayList<>(); 
			subElements = TensorElements();
			Expect(15);
			temp.add(new TensorDefExpr(subElements)); 
			while (la.kind == 7) {
				Get();
				Expect(14);
				subElements = TensorElements();
				Expect(15);
				temp.add(new TensorDefExpr(subElements)); 
			}
		} else if (StartOf(2)) {
			elem = Expression();
			temp.add(elem); 
			while (la.kind == 7) {
				Get();
				elem = Expression();
				temp.add(elem); 
			}
		} else SynErr(57);
		elements = temp; 
		return elements;
	}



	public void Parse() {
		la = new Token();
		la.val = "";		
		Get();
		BOLT();
		Expect(0);

		scanner.buffer.Close();
	}

	private static final boolean[][] set = {
		{_T,_x,_x,_x, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _T,_T,_T,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_T,_T, _x,_x,_x,_x, _x},
		{_x,_T,_T,_T, _T,_x,_T,_x, _x,_x,_x,_x, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_T,_T,_x, _x},
		{_x,_x,_x,_x, _x,_x,_x,_T, _T,_x,_x,_T, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_x,_x,_x, _x}

	};
} // end Parser


class Errors {
	public int count = 0;                                    // number of errors detected
	public java.io.PrintStream errorStream = System.out;     // error messages go to this stream
	public String errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text
	
	protected void printMsg(int line, int column, String msg) {
		StringBuffer b = new StringBuffer(errMsgFormat);
		int pos = b.indexOf("{0}");
		if (pos >= 0) { b.delete(pos, pos+3); b.insert(pos, line); }
		pos = b.indexOf("{1}");
		if (pos >= 0) { b.delete(pos, pos+3); b.insert(pos, column); }
		pos = b.indexOf("{2}");
		if (pos >= 0) b.replace(pos, pos+3, msg);
		errorStream.println(b.toString());
	}
	
	public void SynErr (int line, int col, int n) {
		String s;
		switch (n) {
			case 0: s = "EOF expected"; break;
			case 1: s = "IDENT expected"; break;
			case 2: s = "INTNUM expected"; break;
			case 3: s = "DOUBLENUM expected"; break;
			case 4: s = "CHARLIT expected"; break;
			case 5: s = "\"func:\" expected"; break;
			case 6: s = "\"(\" expected"; break;
			case 7: s = "\",\" expected"; break;
			case 8: s = "\")\" expected"; break;
			case 9: s = "\"{\" expected"; break;
			case 10: s = "\"return\" expected"; break;
			case 11: s = "\";\" expected"; break;
			case 12: s = "\"}\" expected"; break;
			case 13: s = "\"=\" expected"; break;
			case 14: s = "\"[\" expected"; break;
			case 15: s = "\"]\" expected"; break;
			case 16: s = "\"defer\" expected"; break;
			case 17: s = "\"double\" expected"; break;
			case 18: s = "\"int\" expected"; break;
			case 19: s = "\"char\" expected"; break;
			case 20: s = "\"bool\" expected"; break;
			case 21: s = "\"void\" expected"; break;
			case 22: s = "\"vector\" expected"; break;
			case 23: s = "\"matrix\" expected"; break;
			case 24: s = "\"tensor\" expected"; break;
			case 25: s = "\"while\" expected"; break;
			case 26: s = "\"do\" expected"; break;
			case 27: s = "\"if\" expected"; break;
			case 28: s = "\"then\" expected"; break;
			case 29: s = "\"else\" expected"; break;
			case 30: s = "\"||\" expected"; break;
			case 31: s = "\"&&\" expected"; break;
			case 32: s = "\"==\" expected"; break;
			case 33: s = "\"!=\" expected"; break;
			case 34: s = "\"<\" expected"; break;
			case 35: s = "\"<=\" expected"; break;
			case 36: s = "\">\" expected"; break;
			case 37: s = "\">=\" expected"; break;
			case 38: s = "\"+\" expected"; break;
			case 39: s = "\"-\" expected"; break;
			case 40: s = "\"*\" expected"; break;
			case 41: s = "\".*\" expected"; break;
			case 42: s = "\"/\" expected"; break;
			case 43: s = "\"%\" expected"; break;
			case 44: s = "\"!\" expected"; break;
			case 45: s = "\"true\" expected"; break;
			case 46: s = "\"false\" expected"; break;
			case 47: s = "??? expected"; break;
			case 48: s = "this symbol not expected in Program"; break;
			case 49: s = "invalid Type"; break;
			case 50: s = "invalid SimpleStatement"; break;
			case 51: s = "invalid SizeExpression"; break;
			case 52: s = "invalid SimpleType"; break;
			case 53: s = "invalid ComplexType"; break;
			case 54: s = "invalid UnaryExpression"; break;
			case 55: s = "invalid Primary"; break;
			case 56: s = "invalid Primary"; break;
			case 57: s = "invalid TensorElements"; break;
			default: s = "error " + n; break;
		}
		printMsg(line, col, s);
		count++;
	}

	public void SemErr (int line, int col, String s) {	
		printMsg(line, col, s);
		count++;
	}
	
	public void SemErr (String s) {
		errorStream.println(s);
		count++;
	}
	
	public void Warning (int line, int col, String s) {	
		printMsg(line, col, s);
	}
	
	public void Warning (String s) {
		errorStream.println(s);
	}
} // Errors


class FatalError extends RuntimeException {
	public static final long serialVersionUID = 1L;
	public FatalError(String s) { super(s); }
}
